{
    "collab_server" : "",
    "contents" : "#' Posterior Means and 95\\% C.I.s of the NIE, NDE and TE\n#' \n#' Obtain posterior means and credible intervals of the effects.\n#' @param obj1 The fitted model of the observed data under Z=1 from DPdensity\n#' @param obj0 The fitted model of the observed data under Z=0 from Dpdensity\n#' @param q A dimension of the observed data, i.e., number of covariates plus 2\n#' @param NN Number of samples drawn for each iteration from the joint distribution of the mediator and the covariates. Default is 10.\n#' @param n1 Number of observations under Z=1\n#' @param n0 Number of observations under Z=0\n#' @param extra.thin Giving the extra thinning interval\n#' @return ENIE Posterior mean of the NIE\n#' @return ENDE Posterior mean of the NDE\n#' @return ETE Posterior mean of the TE\n#' @return IE.c.i 95\\% C.I. of the NIE\n#' @return DE.c.i 95\\% C.I. of the NDE\n#' @return TE.c.i 95\\% C.I. of the TE\n#' @return Y11 Posterior samples of Y11\n#' @return Y00 Posterior samples of Y00\n#' @return Y10 Posterior samples of Y10\n#' @export\n\n\nbnpmediation<-function(obj1, obj0, q, NN=10, n1, n0, extra.thin=0){\n  \n  library(mnormt)\n  obj1.dim <- dim(obj1$save.state$randsave)[2]-(q*(q+1)/2+2*q-1)\n  obj0.dim <- dim(obj0$save.state$randsave)[2]-(q*(q+1)/2+2*q-1)\n  Len.MCMC <- 1:dim(obj0$save.state$randsave)[1]\n  if(extra.thin!=0){\n    Len.MCMC <- Len.MCMC[seq(1, length(Len.MCMC), extra.thin)]\n  }\n  \n  Ysamples<-OutSamples(obj1, obj0, q)\n  Y11 <- Ysamples$Y1[Len.MCMC]\n  Y00 <- Ysamples$Y0[Len.MCMC]\n  \n  mat.given.ij <- function(x, y) ifelse(x <= y, (q-1)*(x-1)+y-x*(x-1)/2, (q-1)*(y-1)+x-y*(y-1)/2) \n  mat <- function(q) outer( 1:q, 1:q, mat.given.ij ) \n  \n  pb <- txtProgressBar(min = 0, max = length(Len.MCMC), style = 3)\n  \n  Y10<-NULL\n  \n  index<-0\n  for(j in Len.MCMC){\n    index <- index + 1   \n    mu2 <- sapply(seq(2,obj0.dim, by=(q*(q+1)/2+q)), function(x)  obj0$save.state$randsave[j,x[1]:(x[1]+q-2)])\n    sigma22 <- sapply(seq(q+q+1,obj0.dim, by=(q*(q+1)/2+q)), function(x)  obj0$save.state$randsave[j,x[1]:(x[1]+(q-1)*(q)/2-1)][mat(q-1)])\n    joint0 <- do.call(\"rbind\", replicate(NN, data.frame(sapply(1:n0, function(x) rmnorm(1,mu2[,x],matrix(sigma22[,x],q-1,q-1,byrow=T) )))))\n    \n    unique.val <- unique(obj1$save.state$randsave[j,seq(1,obj1.dim,by=(q*(q+1)/2+q))])\n    unique.ind <- NULL\n    unique.prop <- NULL\n    for(k in 1:length(unique.val)){\n      unique.ind[k] <- which(obj1$save.state$randsave[j,seq(1,obj1.dim,by=(q*(q+1)/2+q))]==unique.val[k])[1]\n      unique.prop[k] <- length(which(obj1$save.state$randsave[j,seq(1,obj1.dim,by=(q*(q+1)/2+q))]==unique.val[k]))/n1\n    }\n    b01 <- NULL\n    Weight.num0 <- matrix(nrow=length(unique.val), ncol=n0*NN)\n    B0 <- matrix(nrow=length(unique.val),ncol=n0*NN)\n    \n    t.ind<-0\n    for(k in unique.ind){\n      t.ind<-1+t.ind\n      mu1<-obj1$save.state$randsave[j,(q*(q+1)/2+q)*k-(q*(q+1)/2+q)+1]\n      mu2<-obj1$save.state$randsave[j,((q*(q+1)/2+q)*k-(q*(q+1)/2+q)+2):((q*(q+1)/2+q)*k-(q*(q+1)/2+q)+q)]\n      sigma1<-obj1$save.state$randsave[j,(q*(q+1)/2+q)*k-(q*(q+1)/2+q)+q+1]\n      sigma12<-obj1$save.state$randsave[j,(q*(q+1)/2+q)*k-(q*(q+1)/2+q)+((q+2):(2*q))]\n      sigma22<-matrix(obj1$save.state$randsave[j,((q*(q+1)/2+q)*k-(q*(q+1)/2+q)+2*q+1):((q*(q+1)/2+q)*k)][mat(q-1)],q-1,q-1,byrow=TRUE)\n      Weight.num0[t.ind,1:(n0*NN)]<-unique.prop[t.ind]*dmnorm(joint0,mu2,sigma22)\n      b01[t.ind]<-mu1-sigma12%*%solve(sigma22)%*%t(t(mu2))\n      B0[t.ind,1:(n0*NN)]<-sigma12%*%solve(sigma22)%*%t(joint0)\n    }\n    Weight=apply(Weight.num0, 2, function(x) x/sum(x))\n    test <- Weight*(b01+B0)\n    Y10[index]<-mean(apply(test, 2, sum))\n    Sys.sleep(0.05)\n    setTxtProgressBar(pb, index)\n  }\n  \n  z <- list(Y11=Y11, \n            Y00=Y00, \n            Y10=Y10, \n            ENIE=mean(Y11-Y10), \n            ENDE=mean(Y10-Y00), \n            ETE=mean(Y11-Y00), \n            TE.c.i=c(sort(Y11-Y00)[length(Len.MCMC)*0.025],sort(Y11-Y00)[length(Len.MCMC)*0.975]),\n            IE.c.i=c(sort(Y11-Y10)[length(Len.MCMC)*0.025],sort(Y11-Y10)[length(Len.MCMC)*0.975]),\n            DE.c.i=c(sort(Y10-Y00)[length(Len.MCMC)*0.025],sort(Y10-Y00)[length(Len.MCMC)*0.975]))  \n  z$call <- match.call()\n  class(z) <- \"bnpmediation\"\n  return(z)\n}\n\n\n",
    "created" : 1481356375501.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3626031820",
    "id" : "46F7B47E",
    "lastKnownWriteTime" : 1481356393,
    "last_content_update" : 1481356393171,
    "path" : "~/Dropbox/BNPMediation(package)/R/BNPMediation.R",
    "project_path" : "R/BNPMediation.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}